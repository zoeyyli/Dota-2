[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Dota 2",
    "section": "",
    "text": "1 Introduction\nFor the final project, We chose to analyze the value of abilities in Dota 2’s “Ability Draft” (AD) game mode in order to provide a thoughtful recommendation for ability selections. So what is Dota 2? Dota 2, short for Defense of the Ancients 2, is one of the most popular multiplayer online battle arena (MOBA) video game developed and published by Valve Corporation.\nNow we are going to discuss the detailed context of Dota 2. There are two teams of five players for this game, with each team occupying and defending their territories on a map. Every drafting phase begins by randomly selecting 12 out of the 124 characters or “heroes” in Dota 2. Each hero has four unique abilities associated with them, [QA, WA, EA, RA] for a generic hero A. Of the 12 selected heroes, one is assigned to each of the 10 players (assignment is unique), although the abilities of the unused heroes remain in the drafting pool. Then, in drafting order, each player selects one of the abilities in the pool to assign to their hero. Once all players have four abilities, the drafting phase ends and the players face-off in a five versus five Dota 2 match.\nGold and experience are finite resources in Dota 2 that must be divided amongst teammates. In practice, it is better for some players to receive the majority of the resources because different abilities/heroes require various resources to be maximally effective. In AD, these resources must be intuitively divided by the players on the same team to reach maximum effectiveness.\nConsidering this, we formulate ten research questions to begin our data exploration:\n- Which abilities have the highest average win rate, damage, kills, gold, experiences, etc., and are therefore the most valuable?\n- What is the relationship between heroes and the abilities selected for them?\n- What abilities are successful on the player with the most/fewest resources on a team?\n- How are abilities distributed between teams in one-sided/even matches?\n- Given a drafting pool and a hero, what ability should a player pick?\n- What is the relationship between abilities and items?\n- How do the in-game properties of heroes relate to abilities?\n- What abilities soak large amounts of resources but fail to win the game?\n- Do abilities or heroes function better on radiant or dire?\n- What abilities, heroes, and items are responsible for dealing significant building damage?"
  },
  {
    "objectID": "data.html#technical-description",
    "href": "data.html#technical-description",
    "title": "2  Data",
    "section": "2.1 Technical Description",
    "text": "2.1 Technical Description\nThe data source we chose is OPENDOTA, a third-party, open-source data platform that collects data from Dota 2 games. It includes information concerning player and match statistics by leveraging the Dota 2 API provided by Valve, the parent company of Dota 2. Over five billion matches are stored, and matches can be accessed through the API within hours of their completion.\nThere are approximately 16 quadrillion possible drafts, and 500 million ways to order the heroes in any given AD game of Dota 2. This ensures that no AD match is exactly like another. In our analysis, we will evaluate the effectiveness of each ability across a small subset of these matches.\nWe compiled our dataset by we querying the OPENDOTA API to obtain AD matches. Matches are accessed using a “match_id” parameter. The easiest way to obtain a match_id is to query the API with a ‘player_id’, which fetches the matches that player has played. We used a few additional parameters to ensure that the match was the AD game mode. Unfortunately, there was no way to query the API to receive a match_id independently of a player, so the matches in our dataset were accessed with a player_id 74152970.\nThe response from the API upon requesting a particular match_id is a JSON object containing information pertaining to the match. For example, keys in the response indicate which team won, how long the game was, the total scores of both teams, the chat-log of the game, and the players present in the game. Each of the ten players are nested within the player data, and have their own keys such as their abilities, their number of kills, their total gold earned, and what items they owned.\nWe chose to format our data so that each row represents one player in one match. The columns include the general data from the match as well as the individual player data. In the raw responses, we noticed dozens of fields consistently being left blank. However, most of the information we aimed to collect was preserved and we selected a total of 41 fields to preserve for each data entry, giving us plenty to work with.\nSome data, like the abilities and heroes, are stored as integers rather than names. As a result, we will have to transform these values according to a key that we have obtained from the API. Additionally, a player’s abilities are actually stored in the order in which the player leveled the abilities up. We will need to parse which abilities a player actually has from this list, and decide whether or not to preserve the leveling order. This also raises the edge case of a player having an ability but never leveling it, which—although possible—is incredibly rare.\nWe performed our data compilation in Python and wrote the modified responses into an external CSV file, which we can import into R. Below is the breakdown of columns within the data:\nbarracks_status_dire — integer: dire barracks wellbeing\nbarracks_status_radiant — integer: radiant barracks wellbeing\ndire_score — integer: dire kill score\nduration — integer in seconds: length of the game\nfirst_blood_time — integer in seconds: time of the first kill\nradiant_score — integer: radiant kill score\nradiant_win — boolean: radiant victory\nstart_time — integer: absolute time the game started\ntower_status_radiant — integer: radiant tower wellbeing\nmatch_id — integer: the id of the match\nplayer_slot — integer: 0-4: radiant player order, 128-132: dire player order\nability_upgrades_arr — array (integers): order in which player leveled abilities\naccount_id — integer: player id\nassists — integer: number of kills aided in\ndeaths — integer: number of deaths\ndenies — integer: number of units denied\ngold_per_min — integer: gold accumulated per minute\ngold_spent — integer: gold spent\nhero_damage — integer: damage dealt\nhero_healing — integer: healing provided to teammates\nhero_id — integer: id of the player’s hero\nitem_0 — integer: id of item 0\nitem_1 — integer: id of item 1\nitem_2 — integer: id of item 2\nitem_3 — integer: id of item 3\nitem_4 — integer: id of item 4\nitem_ — integer: id of item 5\nitem_neutral — integer: id of item neutral\nkills — integer: number of kills\nlast_hits — integer: number of last hits  level — integer: hero level at the end of the match\nnet_worth — integer: value of the hero at the end of the match\ntower_damage — integer: damage dealt to enemy buildings\nxp_per_min — integer: experience accumulated per minute\npersonaname — string, None: if available, the username of the player\nisRadiant — boolean: indicates if the player is on radiant\nwin — boolean: indicates if the player won\nkills_per_min — integer: kills acquired per minute\nkda — float: kills / deaths\ntotal_gold — integer: total gold accumulated\ntotal_xp — integer: total experience accumulated\n\nAfter processing responses for over 8 hours, we collected data from a total of 668 matches. The API was very responsive when it came to fetching recent matches, taking only a few seconds, so it is possible that older matches are responsible for slowing down the process."
  },
  {
    "objectID": "data.html#research-plan",
    "href": "data.html#research-plan",
    "title": "2  Data",
    "section": "2.2 Research Plan",
    "text": "2.2 Research Plan\nTo begin our research, we will need to do some final formatting of the data. This includes the formatting of the integer ids for several columns and the parsing of the ability_upgrades_arr column. Additionally, since most of our questions are directed at individual abilities, we will likely split each row into four separate entries, one for each of the abilities possessed by the player.\nAdditionally, considering the differences in what abilities are present from one game to another, it may be helpful to add a column that includes the other abilities that were available in the pool, whether that ability was picked in the draft, and whether it was against or with the ability in the entry.\nOnce the data is processed and cleaned, we can proceed to answering our research questions, as is outlined below:\n\nWhich abilities have the highest average win rate, damage, kills, gold, experiences, etc., and are therefore the most valuable?\nWe could make several bar charts plotting the average of the desired metric for an ability across the dataset. We could also create a scatterplot comparing the relationship between the two metrics and the ability.\nWhat is the relationship between heroes and the abilities selected for them?\nWe could look at individual hero-ability pairings while fixing the ability or the hero and display it in a bar chart. We could also calculate averages for all hero-ability pairings and search for the most and least successful, and plot those pairings. Since there are multiple ‘success’ metrics, we could also create scatterplots to plot hero-ability pairs across two metrics at a time, like gold and experience or kills and deaths.\nAdditionally, it may be interesting to see how common it is for particular heroes to pick an ability. We could plot a bar chart with the total number of times each hero picked an ability.\nWhat abilities are successful on the player with the most/fewest resources on a team?\nWe would need to filter the data to ascertain which heroes on a team were delegated large or small portions of the resources available to the team. Then, we could plot bar charts or scatter plots depicting the effectiveness or ineffectiveness of abilities based on allocated resources.\nHow are abilities distributed between teams in one-sided/even matches?\nWe could filter our data for matches in which the duration was short, the kill-score was one-sided, or the difference in resources between teams was great. Then, we could track the prevalence of abilities on the winning or losing teams.\nGiven a drafting pool and a hero, what ability should a player pick?\nThis is likely the most complicated of our research questions. First, we consider that that value of an ability is the sum of how much value it provides, and how much value it would provide to the enemy. To figure out which ability a player should pick in the draft, we could create facetted, two-by-five heat maps representing the players in the draft.\nIf a player won with the ability, we could add 1 to their tile, and subtract 1 if they lost, and facet for each ability in the drafting pool. Additionally, drafting pools that are more similar hold more predictive weight, but because there are fewer samples the more common draft pools become, the data becomes less reliable. To account for this, we could assign higher weights to more similar pools, or we could further facet the heat maps by the number of abilities held in common between the drafting pools.\n\nIf we have time and would like to do additional data exploration, we could also answer the following questions:\n\nWhat is the relationship between abilities and items?\nWe could perform some exploratory analysis on the ability-item pairings, similar to hero-ability pairings.\nHow do the in-game properties of heroes relate to abilities?\nIn Dota 2, the heroes themselves have properties associated with them, like health, armor, and mana. The OPENDOTA API also includes this information, and we could augment our data with the base values of each hero to perform additional analysis and look for trends.\nWhat abilities soak large amounts of resources but fail to win the game?\nWe could filter for lost games and tally the abilities present on the rich members of the losing team.\nDo abilities or heroes function better on radiant or dire?\nWe could filter the data by which team the ability was present on and see if there are any trends. There are three abilities that have different functions depending on what team they are on, and we may see some difference in effectiveness for these abilities.\nWhat abilities, heroes, and items are responsible for dealing significant building damage?\nWe could take the building damage dealt by a player with an ability, and tally the total building damage of all of the abilities.  Depending on the results of our exploration and analysis, we may choose to pursue these questions or others. But these ideas give us a place to start when exploring the data. We hope we will come across patterns that lead to further questions that we can’t anticipate!"
  },
  {
    "objectID": "data.html#missing-value-analysis",
    "href": "data.html#missing-value-analysis",
    "title": "2  Data",
    "section": "2.3 Missing value analysis",
    "text": "2.3 Missing value analysis\n\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.3     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.4     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\nRows: 6680 Columns: 41\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): ability_upgrades_arr, hero_id, personaname\ndbl (36): barracks_status_dire, barracks_status_radiant, dire_score, duratio...\nlgl  (2): radiant_win, isRadiant\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\n\n\n\n\n\nIn the figure above, we can see the number of missing values in each column. Immediately, we notice massive values in the tower_damage, hero_healing, hero_damage, gold_spent, ability_upgrades_arr, personaname, account_id, and kills_per_min columns.\nSome accounts are private and are therefore not stored in the system, which explains the missing data in the account_id and personaname columns.\nThe kills_per_min column has a missing value if the player achieved no kills during the course of the match, so these values are actually 0.\nWe are not sure what is responsible for the gaps in tower_damage, hero_healing, hero_damage, gold_spent, ability_upgrades_arr. It is particularly troublesome considering that the ability_upgrades_arr column is crucial for analysis. After querying the API for over 8 hours, we halted the process early, but it seems unlikely that that would have been responsible for the gaps. More likely, there are just gaps or errors in OPENDOTA’s data collection. Luckily, the same rows are missing multiple columns, leaving us with well over 3000 samples to begin analysis with."
  },
  {
    "objectID": "data.html#data-cleaning",
    "href": "data.html#data-cleaning",
    "title": "2  Data",
    "section": "2.4 Data Cleaning",
    "text": "2.4 Data Cleaning\nOnce we had obtained the raw match data from the API, we needed to transform it into a more readable and workable form. All of the information we needed on abilities was stored in one column called “ability_upgrades_arr.” This column represented the abilities in the order they were upgraded by the player, but also included other information about leveling up that we did not need. In order to filter out information on the abilities, we obtained a an ability id key from the API and used it to convert the integers into strings. The name of a player’s hero was also stored as an integer, and we obtained a similar key to decode the values.\nOnce we had curated the data frame, we wrote it into a CSV file. However, we realized that the data would be easier to work with if each row was split into four rows, one for each ability. We opened the CSV file back up, split the rows, and changed the column to the ‘ability’ column with one of the abilities. We also excluded any row that was missing ability data. This solved all of our concerns on missing data and left us with enough samples to perform exploratory analysis. We then wrote our data frame into a new CSV file and began our analysis.\nThe file in which we performed this preprocessing can be accessed here: Link\n\n\nRows: 12911 Columns: 41\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr  (3): ability, hero, personaname\ndbl (36): barracks_status_dire, barracks_status_radiant, dire_score, duratio...\nlgl  (2): radiant_win, isRadiant\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nCoordinate system already present. Adding new coordinate system, which will\nreplace the existing one.\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale.\nScale for y is already present.\nAdding another scale for y, which will replace the existing scale."
  },
  {
    "objectID": "results.html#good-and-bad-abilities",
    "href": "results.html#good-and-bad-abilities",
    "title": "3  Results",
    "section": "3.1 Good and Bad Abilities",
    "text": "3.1 Good and Bad Abilities\n\n\nCode\ndfc = as.data.frame(table(dota2$ability))\nnames(dfc)[1] = 'ability'\ndfc &lt;- dfc[dfc$Freq &gt; 29,]\n\ndota2 &lt;- dota2[dota2$ability %in% dfc$ability,]\n\nwldf &lt;- dota2[,c(\"win\", \"ability\")]\n\nwldf &lt;- wldf %&gt;%\n  filter(win == 1) %&gt;%  # Consider only the rows where the round was won\n  group_by(ability) %&gt;%\n  summarise(wins = n())\n\nwldf &lt;- merge(wldf, dfc, by = \"ability\", all.x = TRUE)\nwldf$winrate &lt;- wldf$wins / wldf$Freq\nwldf &lt;- wldf[order(-wldf$winrate),]\nwlends &lt;- rbind(head(wldf, 10), tail(wldf, 10))\n\nwlends &lt;- wlends %&gt;%\n  mutate(new_col = ifelse(row_number() &lt;= 10, \"Best Abilities\", ifelse(row_number() &gt; n() - 10, \"Worst Abilities\", NA)))\n\nggplot(wlends, aes(x=reorder(ability,winrate),y=winrate))+\n  geom_col(color='lightblue', fill ='lightblue', width=0.8)+\n  facet_wrap(~new_col)+\n  labs(title=\"The 10 Best and Worst Abilities by Winrate\", x=\"Ability\", y = \"Winrate\")+\n  theme(\n    axis.text.x = element_text(angle = 90, size = 8),\n    plot.title = element_text(color = \"black\", face = \"bold\", hjust = 0.5)\n  ) +\n  coord_flip()\n\n\n\n\n\n\n\nCode\n#saved for d3 use\ndf_d3 &lt;- wlends[,c('ability','winrate')]\n\n\nThere are over 500 abilities in total, which is an extremely large pool. In order to answer the research questions, we need to select the abilities we would like to analyze. Before we discover which abilities are good or bad, we should make sure that we are working with a good sample size. To accomplish this, we will only consider abilities that appear in at least 30 matches. Then, we can calculate the total number of wins associated with each ability and determine the win rate by dividing by frequency. The results are plotted above. We can see Slark’s “Shadow Dance” topping the chart with a 77.78% winrate, while Tidehunter’s “Anchor Smash” is at 22.58% on the bottom.\n\n\nCode\ndfh = as.data.frame(table(dota2$hero))\nnames(dfh)[1] = 'hero'\n\nwlhdf &lt;- dota2[,c(\"win\", \"hero\")]\n\nwlhdf &lt;- wlhdf %&gt;%\n  filter(win == 1) %&gt;%  # Consider only the rows where the round was won\n  group_by(hero) %&gt;%\n  summarise(wins = n())\n\nwlhdf &lt;- merge(wlhdf, dfh, by = \"hero\", all.x = TRUE)\nwlhdf$winrate &lt;- wlhdf$wins / wlhdf$Freq\nwlhdf &lt;- wlhdf[order(-wlhdf$winrate),]\nwlhends &lt;- rbind(head(wlhdf, 10), tail(wlhdf, 10))\n\nwlhends &lt;- wlhends %&gt;%\n  mutate(new_col = ifelse(row_number() &lt;= 10, \"Best Heroes\", ifelse(row_number() &gt; n() - 10, \"Worst Heroes\", NA)))\n\nggplot(wlhends, aes(x=reorder(hero,winrate),y=winrate))+\n  geom_col(color='pink', fill ='pink', width=0.8)+\n  facet_wrap(~new_col)+\n  labs(title=\"The 10 Best and 10 Worst Heroes by Winrate\", x=\"Ability\", y = \"Winrate\")+\n  theme(\n    axis.text.x = element_text(angle = 90, size = 8),\n    plot.title = element_text(color = \"black\", face = \"bold\", hjust = 0.5)\n  ) +\n  coord_flip()\n\n\n\n\n\nThis is the barplots of 10 best heroes and 10 worst heroes selected from the original dataset based on their win rates. From this graph, we can see for what heroes tend to have higher win rate, which will also affect the effectiveness of the abilities chosen which will be further analyzed below. From the plots we can see the top heroes such as Mars and Bane have almost win rate of 0.8 which is really high.\n\n\nCode\ndf &lt;- wlends\ndf &lt;- df[order(df$Freq,decreasing=TRUE),]\ndf &lt;- head(df,10)\nsaved_for_fourth &lt;- dota2[dota2$ability %in% df$ability,]\ndota2 &lt;- dota2[dota2$ability %in% df$ability,]"
  },
  {
    "objectID": "results.html#which-abilities-have-the-highest-kills-gold-experiences-points-and-kda-and-are-therefore-the-most-valuable",
    "href": "results.html#which-abilities-have-the-highest-kills-gold-experiences-points-and-kda-and-are-therefore-the-most-valuable",
    "title": "3  Results",
    "section": "3.2 Which abilities have the highest kills, gold, experiences points, and kda, and are therefore the most valuable?",
    "text": "3.2 Which abilities have the highest kills, gold, experiences points, and kda, and are therefore the most valuable?\nTo answer the question, we decide to draw parallel coordinate plots which is useful when we want to get the abilities that top the charts in all four indicators. It’s important to note that kda is a statistic that is used to measure a player’s performance.\n\n\nCode\ndf_ability &lt;- dota2[,c(\"total_gold\",\"kills\",\"kda\",\"total_xp\", \"ability\")]\nGGally::ggparcoord(data = df_ability, columns = 1:4, alphaLines = .4, groupColumn = 5, splineFactor = TRUE, title = \"Parallel Coordinates Plot\")\n\n\n\n\n\nThis is the parallel coordinate plot colored by abilities so that we can see the trend of lines of different colors. In general, the data values are compact with only one line colored pink with extremely high value of kda that belongs to the ability “slark_shadow_dance”(might be outlier).\n\n\nCode\ndf &lt;- dota2[,c(\"total_gold\",\"kills\",\"kda\",\"total_xp\")]\nparcoords::parcoords(data = df, rownames = FALSE, brushMode = \"1d-axes\")\n\n\n\n\n\n\nThis is the interactive parallel coordinate plot for all 10 abilities. We make it interactive such that we can move axis around and we can filter for particular section which easier to see the top abilities. However, since the dataset is too large, the lines overlap, so we need to select specific region to interpret the plot.\n\n\nCode\ndf &lt;- df[df$kills &gt; 16 & df$kda &gt;= 10,]\nparcoords::parcoords(data = df, rownames = FALSE, brushMode = \"1d-axes\")\n\n\n\n\n\n\nFrom the interactive parallel coordinate plot, I select a specific region where these abilities have relatively high values across all four variables, kills, gold, experiences points earned, and kda, and I filter the dataset based on that.\n\n\nCode\ndf_ability &lt;- df_ability[df_ability$kills &gt; 16 & df_ability$kda &gt;= 10,]\ndf_ability\n\n\n     total_gold kills   kda total_xp                   ability\n1009      40849    17 19.00    45425         omniknight_martyr\n2098      32981    18 15.50    41839 winter_wyvern_arctic_burn\n2390      44698    18 10.67    45746        slark_shadow_dance\n2393      44698    18 10.67    45746         omniknight_martyr\n6197      26092    17 10.67    35515  necrolyte_reapers_scythe\n\n\nFrom the data frame we can see two of the rows are from same ability. In total, I select 4 top abilities through these parallel coordinate plots, which are the following:\n1. omniknight_martyr\n2. winter_wyvern_arctic_burn\n3. slark_shadow_dance\n4. necrolyte_reapers_scythe"
  },
  {
    "objectID": "results.html#do-these-four-good-abilities-function-better-on-radiant-or-dire",
    "href": "results.html#do-these-four-good-abilities-function-better-on-radiant-or-dire",
    "title": "3  Results",
    "section": "3.3 Do these four good abilities function better on radiant or dire?",
    "text": "3.3 Do these four good abilities function better on radiant or dire?\nTo answer the question, we decide to draw mosaic plot here because it can incorporate group size into account and can clearly show the relationship between multiple categorical variables, which are win (1 is win and 0 is lose), isRadient(True is radient and False is dire), and ability in our case.\n\n\nCode\ndota2 &lt;- read.csv(\"addata.csv\")\ndf_2 &lt;- dota2[dota2$ability == \"omniknight_martyr\" | dota2$ability == \"slark_shadow_dance\" | dota2$ability == \"winter_wyvern_arctic_burn\" | dota2$ability == \"necrolyte_reapers_scythe\",]\ndf_2[df_2 == \"omniknight_martyr\"] &lt;- 'o'\ndf_2[df_2 == \"slark_shadow_dance\"] &lt;- 's'\ndf_2[df_2 == \"winter_wyvern_arctic_burn\"] &lt;- 'w'\ndf_2[df_2 == \"necrolyte_reapers_scythe\"] &lt;- 'n'\n\nvcd::mosaic(win~ability+isRadiant, data = df_2, direction = c(\"v\",\"v\",\"h\"), main = \"Mosaic Plot of Wins on Abilities and Radiant/Dire\", highlighting_fill= matrix(c(\"lightblue\",\"grey\"),)) \n\n\n\n\n\nIn this mosaic plot, label ‘n’ represents the ability “necrolyte_reapers_scythe”; ‘o’ represents the ability “omniknight_martyr”; ‘s’ represents the ability “slark_shadow_dance”; ‘w’ represents the ability “winter_wyvern_arctic_burn”. These abbreviations make the plot clearer to read by avoiding label overlaps.\nFrom the above mosaic plot, we can see for the three abilities “omniknight_martyr”, “slark_shadow_dance”, and “winter_wyvern_arctic_burn”, they perform significantly better on radiant, while for the ability “necrolyte_reapers_scythe”, it performs better on dire (not radiant). In our case, these four abilities function much better on radiant."
  },
  {
    "objectID": "results.html#what-heroes-are-most-commonly-associated-with-the-four-good-abilities",
    "href": "results.html#what-heroes-are-most-commonly-associated-with-the-four-good-abilities",
    "title": "3  Results",
    "section": "3.4 What heroes are most commonly associated with the four good abilities?",
    "text": "3.4 What heroes are most commonly associated with the four good abilities?\nThis question can be answered by drawing the separate barplots for each ability. When people are assigned hero, these heroes are designed with a specific role in mind, so they have tendence to select correlated abilities. From the barplots we can know what heroes are highly correlated to the selection of each ability among all four.\n\n\nCode\ndf_n &lt;- df_2[df_2$ability == \"n\",] \ndf_n = as.data.frame(table(df_n$hero))\nnames(df_n)[1] = 'hero'\ndf_n$rank = rank(df_n$Freq)\ndf_n &lt;- df_n[order(df_n$rank,decreasing=TRUE),]\n\na = ggplot(df_n, aes(x=reorder(hero,-Freq),y=Freq))+\n  geom_col(color='pink', fill ='lightpink', width=0.8)+\n  labs(title=\"Count of Hero Associated with 'n'\",x=\"hero\", y = \"Count\")+\n  theme(axis.text.x = element_text(angle = 90, hjust=1, size = 8)) \n\ndf_s &lt;- df_2[df_2$ability == \"s\",] \ndf_s = as.data.frame(table(df_s$hero))\nnames(df_s)[1] = 'hero'\ndf_s$rank = rank(df_s$Freq)\ndf_s &lt;- df_s[order(df_s$rank,decreasing=TRUE),]\n\nb = ggplot(df_s, aes(x=reorder(hero,-Freq),y=Freq))+\n  geom_col(color='pink', fill ='lightpink', width=0.8)+\n  labs(title=\"Count of Hero Associated with 's'\",x=\"hero\", y = \"Count\")+\n  theme(axis.text.x = element_text(angle = 90, hjust=1, size = 8)) \n\ndf_o &lt;- df_2[df_2$ability == \"o\",] \ndf_o = as.data.frame(table(df_o$hero))\nnames(df_o)[1] = 'hero'\ndf_o$rank = rank(df_o$Freq)\ndf_o &lt;- df_o[order(df_o$rank,decreasing=TRUE),]\n\nc = ggplot(df_o, aes(x=reorder(hero,-Freq),y=Freq))+\n  geom_col(color='pink', fill ='lightpink', width=0.8)+\n  labs(title=\"Count of Hero Associated with 'o'\",x=\"hero\", y = \"Count\")+\n  theme(axis.text.x = element_text(angle = 90, hjust=1, size = 8)) \n\ndf_w &lt;- df_2[df_2$ability == \"w\",] \ndf_w = as.data.frame(table(df_w$hero))\nnames(df_w)[1] = 'hero'\ndf_w$rank = rank(df_w$Freq)\ndf_w &lt;- df_w[order(df_w$rank,decreasing=TRUE),]\n\nd = ggplot(df_w, aes(x=reorder(hero,-Freq),y=Freq))+\n  geom_col(color='pink', fill ='lightpink', width=0.8)+\n  labs(title=\"Count of Hero Associated with 'w'\",x=\"hero\", y = \"Count\")+\n  theme(axis.text.x = element_text(angle = 90, hjust=1, size = 8)) \n\nggarrange(a,b,c,d,common.legend = TRUE, legend = \"bottom\")\n\n\n\n\n\nFrom above barplots, we can see the heroes Lifeastealer and Nechrophos tends to be highly associated with the ability “necrolyte_reapers_scythe”; the hero Slark is highest correlated to the ability “slark_shadow_dance”; the hero Omniknight is highest correlated to the ability “omniknight_martyr”; the hero Winter Wyvern is highest correlated to the ability “winter_wyvern_arctic_burn”. When people are randomly assigned these heroes, they are more likely to also select these four good abilities with a significant frequency difference compared to other heroes."
  },
  {
    "objectID": "results.html#how-many-resources-are-consumed-by-these-four-abilities-compared-to-the-the-other-abilities",
    "href": "results.html#how-many-resources-are-consumed-by-these-four-abilities-compared-to-the-the-other-abilities",
    "title": "3  Results",
    "section": "3.5 How many resources are consumed by these four abilities compared to the the other abilities?",
    "text": "3.5 How many resources are consumed by these four abilities compared to the the other abilities?\nWe want to draw histograms of continuous variable net worth faceted by all 10 abilities to see the distribution of net resources of each player possessing good abilities compared to rest of the abilities. In other words, this information gives us the total cost of choosing the four good abilities selected.\n\n\nCode\nsaved_for_fourth[saved_for_fourth == \"omniknight_martyr\"] &lt;- 'o'\nsaved_for_fourth[saved_for_fourth == \"slark_shadow_dance\"] &lt;- 's'\nsaved_for_fourth[saved_for_fourth == \"winter_wyvern_arctic_burn\"] &lt;- 'w'\nsaved_for_fourth[saved_for_fourth == \"necrolyte_reapers_scythe\"] &lt;- 'n'\n\n\n\n\nCode\nggplot(saved_for_fourth, aes(net_worth))+\n  geom_histogram(color = 'cornflowerblue', fill = 'lightblue', bins=15)+\n  facet_wrap(~ability)+\n  ggtitle(\"Faceted Histogram of Net Worth\")+\n  theme_grey(9)\n\n\n\n\n\nFrom these histograms, we can see that the abilities “necrolyte_reapers_scythe” and “slark_shadow_dance” use relatively limited amount of resources, while the abilities “omniknight_martyr” and “winter_wyvern_arctic_burn” use relatively large amount of resources, meaning that there’s higher cost selecting these abilities."
  },
  {
    "objectID": "results.html#analysis-of-two-popular-abilities-based-on-various-metrics",
    "href": "results.html#analysis-of-two-popular-abilities-based-on-various-metrics",
    "title": "3  Results",
    "section": "3.6 Analysis of Two Popular Abilities Based on Various Metrics",
    "text": "3.6 Analysis of Two Popular Abilities Based on Various Metrics\nWe decide to do an additional analysis on two popular abilities (other than the abilities we’ve analyzed before) to see how they perform overall in the game, which can serve as an example to help player make a selection between two abilities when they have a hard time deciding which one to choose. We decide to create two scatterplot matrices to see how each perform under five metrics “kills”, “deaths”, “duration”, “hero_damage”, and “last_hits”.\n\n\nCode\nasdf = filter(dota2, ability == \"tidehunter_anchor_smash\")\n\navg_values &lt;- colMeans(dota2[, c('kills','deaths','duration','hero_damage','last_hits')])\navg_values['win'] = 0.5\n\nasdf = asdf[,c('win', 'kills','deaths','duration','hero_damage','last_hits')]\n\nasdf &lt;- rbind(asdf, as.data.frame(t(avg_values)))\n\nasdf &lt;- asdf %&gt;%\n  mutate_at(vars(-win), as.numeric)\n\nasdf &lt;- asdf %&gt;%\n  mutate_at(vars(win), as.character)\n\n#asdf &lt;- dplyr::select(asdf, kills, deaths, duration, hero_damage)\n\ncolors &lt;- c('indianred', 'forestgreen', 'navy')\nplot(\n  main = 'Metrics for Anchor Smash Players',\n  asdf[2:6],\n  pch = ifelse(asdf$win == 0.5, 15, 16),\n  cex = 1,\n  col = ifelse(asdf$win == 0,\"indianred\", \n                ifelse(asdf$win == 0.5, \"forestgreen\", \"navy\"))\n)\n\npar(xpd = TRUE)\n\nlegend(\n  .2, -.02,\n  xpd = 'NA',\n  legend = c('Win', 'Loss', 'Average for All Abilities'),\n  col = c(\"indianred\",\"navy\", \"forestgreen\"),\n  pch=c(16,16,15),\n  horiz = TRUE,\n  cex = .75,\n  bty = \"n\"\n)\n\n\nWarning in par(xpd = xpd): NAs introduced by coercion\n\n\n\n\n\nBy comparing the various metrics, we can assess how having anchor smash affects a player’s game. In the plot of kills versus deaths, we can see that while players with anchor smash don’t necessarily die more often, their number of kills (particularly in losing games) is often below average. The duration of the matches appears relatively unaffected by anchor smash. But, if we look at the last_hits versus hero_damage plot, we can see that players with anchor smash are collecting more resources than average while doing less damage than average. This is really the nightmare scenario for an ability: requiring lots of resources and still being ineffective.\nIn Dota 2, many abilities deal a set amount of damage. Anchor Smash, however, deals damage based on a hero’s damage statistic, which can be improved by items and levels. This chart shows us that anchor smash is an ineffective ability because players invest lots of resources into improving anchor smash, but fail to actually use it to get kills on enemy heroes.\n\n\nCode\nsddf = filter(dota2, ability == \"slark_shadow_dance\")\n\navg_values &lt;- colMeans(dota2[, c('kills','deaths','duration','hero_damage','last_hits')])\navg_values['win'] = 0.5\n\nsddf = sddf[,c('win', 'kills','deaths','duration','hero_damage','last_hits')]\n\nsddf &lt;- rbind(sddf, as.data.frame(t(avg_values)))\n\nsddf &lt;- sddf %&gt;%\n  mutate_at(vars(-win), as.numeric)\n\nsddf &lt;- sddf %&gt;%\n  mutate_at(vars(win), as.character)\n\ncolors &lt;- c('indianred', 'forestgreen', 'navy')\nplot(\n  main = 'Metrics for Shadow Dance Players',\n  sddf[2:6],\n  pch = ifelse(sddf$win == 0.5, 15, 16),\n  cex = 1,\n  col = ifelse(sddf$win == 0,\"indianred\", \n                ifelse(sddf$win == 0.5, \"forestgreen\", \"navy\"))\n)\n\npar(xpd = TRUE)\n\nlegend(\n  .2, -.02,\n  xpd = 'NA',\n  legend = c('Win', 'Loss', 'Average for All Abilities'),\n  col = c(\"indianred\",\"navy\", \"forestgreen\"),\n  pch=c(16,16,15),\n  horiz = TRUE,\n  cex = .75,\n  bty = \"n\"\n)\n\n\nWarning in par(xpd = xpd): NAs introduced by coercion\n\n\n\n\n\nIn comparison, we can see how a player’s game is affected by shadow dance. Looking at the kills versus deaths chart, we can see that especially in winning games, players with shadow dance have very few deaths. Shadow dance players also seem to have slightly below average kills, however, there are three outliers in winning games where the player has over a dozen kills and less than 5 deaths. This plot suggests that shadow dance makes a player more survivable.\nWhile the average duration of shadow dance matches appears to align with the global average for abilities, there is a large range. In both very short and very long games, shadow dance yields the player a victory. Dota 2 players know that the game has dynamic game states depending on the current game time. This chart shows us that shadow dance is a strong spell both early, middle, and very late game. If shadow dance has any weakness, it is between the 2000 and 2500 mark, which is know as late game.\nIn the plot of deaths versus duration, we can also see that there are several games past the 2500 mark where the player has fewer than 5 deaths, which is remarkable. In comparison, we can see the only two games that went very late for anchor smash both had 8 or more deaths.\nLooking at hero_damage versus last_hits, we can see that the majority of shadow dance games are below average on last hits with relatively low hero damage, yet are still victories. There are a few points with very high last hit counts and high or medium damage. This chart again highlights the versatility of shadow dance: with shadow dance, a player can soak very few resources, but still manage to win a majority of games, or they take many resources, increase their damage, and win the game. Compared to anchor smash, shadow dance is more versatile and effective, allowing the player to adapt their game play while providing good impact to the team.\nUnlike anchor smash, shadow dance is an ability that does not do any damage at all. Instead, it gives the player large amounts of healing, a period of near invincibility every minute, and alerts the player when the enemy team can see them. While anchor smash only has one use, shadow dance has many, and is a solid choice for any hero in the game."
  },
  {
    "objectID": "d3graph.html",
    "href": "d3graph.html",
    "title": "4  Interactive graph",
    "section": "",
    "text": "Do you know the game Dota2?\n\nYes No\n\n\n\n\nPlease select one ability below to see its win rate:\n\n slark shadow dance  disruptor thunder strike  necrolyte reapers scythe  phoenix icarus dive  sniper assassinate  earthshaker aftershock  windrunner windrun  omniknight martyr  tidehunter anchor smash  beastmaster wild axes\n\n\n\n\n\n\nPlease select one hero below to see its win rate:\n\n Mars  Elder Titan  Batrider  Slark  Lone Druid  Zeus  Broodmother  Phantom Assassin  Undying  Bane\n\n\n\n\n\n\nNow look at the important attributes for each ability:\n\n slark shadow dance  disruptor thunder strike  necrolyte reapers scythe  phoenix icarus dive  sniper assassinate  earthshaker aftershock  windrunner windrun  omniknight martyr  tidehunter anchor smash  beastmaster wild axes"
  },
  {
    "objectID": "conclusion.html",
    "href": "conclusion.html",
    "title": "5  Conclusion",
    "section": "",
    "text": "We realize for some of the research questions, it’s hard to visualize. Consequently, we choose to answer four of our research questions among all ten listed in introduction that are essential and can be visualized with tools learnt in class. Additionally we add one analysis on comparison between two specific abilities.\nFirstly, among the 10 best abilities selected through win rate analysis, the four abilities “omniknight_martyr”, “winter_wyvern_arctic_burn”, “slark_shadow_dance”, and “necrolyte_reapers_scythe” have the highest kills, gold, experiences points, and kda (a statistic that is used to measure a player’s performance), and are therefore the most valuable based on our analysis. Secondly, for these four abilities selected, they function better on radient instead of dire. Thirdly, each ability is tied to different heroes. The heroes Lifeastealer and Nechrophos tends to be highly associated with the ability “necrolyte_reapers_scythe”; the hero Slark is highest correlated to the ability “slark_shadow_dance”; the hero Omniknight is highest correlated to the ability “omniknight_martyr”; the hero Winter Wyvern is highest correlated to the ability “winter_wyvern_arctic_burn”. Thus, when we want to select four abilities in the game mode, we need to notice the compatibility between the assigned hero and the abilities. Fourthly, we examine the resources consumed of the player possessing these four abilities compared to other abilities, and we conclude that some of these abilities might take higher cost than the others. In the end, we provide a way to do the selection between 2 popular abilities in Dota2 other than the ones we’ve analyzed before, and we conclude that the ability “shadow dance” is a significantly better choice than the other one.\nThe most essential limitation in our research is that, in theory, there is a total of over 500 abilities that need to be analyzed. However, it’s hard to visualize such large set of abilities, and also many abilities have very limited amount of data, so we decide to only do research on the abilities selected through higher win rate. It’s possible that abilities other than these 10 best abilities selected to be more valuable. Thus, in the future, it’s better to collect more data to gain more information regarding all abilities, and we also need to figure out better ways to visualize such large dataset so that our conclusion would be more comprehensive.\nDuring our research process, we learnt the importance of data preprocessing before start graphing. For example,at the beginning, the abilities are arrays with four integers in each, and we realize it’s hard to draw any graphs by using such dataset. Then, we need to go back and converted them back to ability names and separate each row into four rows. This process should be better done before starting data visualization."
  }
]